Создаётся Telegram Mini App ― анонимный чат/мини-мессенджер, работающий внутри Telegram WebApp.
Цель: протестировать MVP с минимальным набором функций, чтобы потом перенести на полноценный сервер (VPS/Docker).

Общая концепция

Пользователь открывает Mini App через Telegram-бота.

Происходит авторизация через initData Telegram WebApp (без привязки к личному аккаунту, для анонимности).

Приложение создаёт временный «анонимный профиль» (никнейм, аватар, 3 фото профиля).

Пользователь может писать в общий глобальный чат, а также в малые комнаты (например, до 6 человек).

Сообщения и медиа сохраняются в базе данных.

В будущем будет возможность загружать изображения (аватары, фото), хранить их в S3.

Архитектура

Frontend (React + Vite): интерфейс чата, работающий в WebView Telegram.

Backend (Node.js + Fastify + Socket.IO):

REST API для авторизации, загрузки профиля, истории сообщений.

WebSocket (Socket.IO) для обмена сообщениями в реальном времени.

Базы данных:

PostgreSQL — хранение пользователей, комнат и сообщений.

Redis — хранение сессий и pub/sub для масштабирования WebSocket.

S3 (MinIO / AWS S3) — хранение медиа (аватарки, фото).

Минимальные фичи MVP

Авторизация через Telegram initData.

Генерация анонимного профиля при входе.

Глобальный чат с сообщениями.

Простое хранение сообщений в PostgreSQL.

WebSocket-события: подключение, отправка сообщения, получение сообщений.




root/package.json
{
  "name": "tg-miniapp-mvp",
  "private": true,
  "scripts": {
    "dev": "concurrently \"cd backend && npm run dev\" \"cd frontend && npm run dev\""
  },
  "devDependencies": {
    "concurrently": "^8.0.0"
  }
}

docker-compose.yml (локальная dev-среда)
version: "3.8"
services:
  postgres:
    image: postgres:15
    environment:
      POSTGRES_PASSWORD: password
      POSTGRES_DB: chatdb
    ports:
      - "5432:5432"
    volumes:
      - pgdata:/var/lib/postgresql/data

  redis:
    image: redis:7
    ports:
      - "6379:6379"

  minio:
    image: minio/minio
    environment:
      MINIO_ROOT_USER: minioaccesskey
      MINIO_ROOT_PASSWORD: miniosecretkey
    command: server /data
    ports:
      - "9000:9000"

volumes:
  pgdata:

backend/package.json
{
  "name": "backend",
  "version": "1.0.0",
  "main": "dist/server.js",
  "scripts": {
    "dev": "ts-node-dev --respawn --transpile-only src/server.ts",
    "build": "tsc -p .",
    "start": "node dist/server.js"
  },
  "dependencies": {
    "fastify": "^4.20.0",
    "fastify-socket.io": "^2.6.0",
    "pg": "^8.10.0",
    "ioredis": "^5.3.2",
    "dotenv": "^16.0.0",
    "@aws-sdk/client-s3": "^3.0.0"
  },
  "devDependencies": {
    "ts-node-dev": "^2.0.0",
    "typescript": "^5.0.0"
  }
}

backend/tsconfig.json
{ "compilerOptions": {
  "target": "ES2020",
  "module": "commonjs",
  "outDir": "dist",
  "rootDir": "src",
  "strict": true,
  "esModuleInterop": true,
  "skipLibCheck": true
}}

backend/src/db.ts
import { Pool } from 'pg';
import dotenv from 'dotenv';
dotenv.config();

export const pool = new Pool({
  connectionString: process.env.DATABASE_URL
});

export async function initDb() {
  // run basic init if necessary - in dev, you may run sql/init.sql manually
  await pool.query(`
  CREATE TABLE IF NOT EXISTS users(
    id SERIAL PRIMARY KEY,
    tg_user_id BIGINT NULL UNIQUE,
    anon_name TEXT,
    avatar_url TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT now()
  );
  CREATE TABLE IF NOT EXISTS rooms(
    id SERIAL PRIMARY KEY,
    name TEXT,
    type TEXT DEFAULT 'group',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT now()
  );
  CREATE TABLE IF NOT EXISTS messages(
    id SERIAL PRIMARY KEY,
    room_id INTEGER REFERENCES rooms(id) ON DELETE CASCADE,
    user_id INTEGER REFERENCES users(id) ON DELETE SET NULL,
    content TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT now()
  );
  `);
}

backend/src/telegramAuth.ts
import crypto from 'crypto';
import querystring from 'querystring';

export function parseInitData(initData: string) {
  // Telegram sends initData as "key=value&key2=value2..."
  const obj = querystring.parse(initData);
  return obj; // keys like user, auth_date, hash, etc.
}

export function verifyInitData(initData: string, botToken: string) {
  // Algorithm per Telegram docs:
  // 1. Parse pairs, remove 'hash', sort keys
  // 2. Build data_check_string with lines "key=value"
  // 3. secret_key = sha256(botToken)
  // 4. hmac = HMAC_SHA256(secret_key, data_check_string)
  // 5. compare hex digests (safe compare)
  const params = initData.split('&').map(p => p.split('='));
  const kv: Record<string,string> = {};
  for (const [k, v] of params) {
    if (!k) continue;
    kv[k] = decodeURIComponent(v || '');
  }
  const hash = kv['hash'];
  if (!hash) return false;
  const keys = Object.keys(kv).filter(k => k !== 'hash').sort();
  const data_check_arr = keys.map(k => `${k}=${kv[k]}`);
  const data_check_string = data_check_arr.join('\n');

  const secret = crypto.createHash('sha256').update(botToken).digest();
  const hmac = crypto.createHmac('sha256', secret).update(data_check_string).digest('hex');

  // safe compare
  return crypto.timingSafeEqual(Buffer.from(hmac, 'hex'), Buffer.from(hash, 'hex'));
}

backend/src/socket.ts
import { FastifyInstance } from 'fastify';
import { Server as IOServer } from 'socket.io';
import { pool } from './db';

export function setupSocket(fastify: FastifyInstance) {
  const io: IOServer = (fastify as any).io;

  io.on('connection', (socket) => {
    fastify.log.info(`socket connected: ${socket.id}`);

    // authentication — you may pass token on connection or first event
    socket.on('auth', async (payload) => {
      // payload = { token }
      // TODO: verify session token stored in Redis or DB
      socket.join('global'); // default room for MVP
      socket.emit('joined', { room: 'global' });
    });

    socket.on('join', async ({ roomId }) => {
      socket.join(String(roomId));
    });

    socket.on('message', async (msg) => {
      // msg = { roomId, userId, content }
      // Basic validation
      if (!msg || !msg.content) return;
      // store message in DB
      try {
        const res = await pool.query(
          'INSERT INTO messages(room_id, user_id, content) VALUES($1,$2,$3) RETURNING id, created_at',
          [msg.roomId || 1, msg.userId || null, msg.content]
        );
        const saved = {
          id: res.rows[0].id,
          content: msg.content,
          userId: msg.userId,
          roomId: msg.roomId || 1,
          created_at: res.rows[0].created_at
        };
        io.to(String(saved.roomId)).emit('message', saved);
      } catch (e) {
        fastify.log.error(e);
      }
    });

    socket.on('disconnect', () => {
      fastify.log.info(`socket disconnect: ${socket.id}`);
    });
  });
}

backend/src/routes.ts
import { FastifyInstance } from 'fastify';
import { parseInitData, verifyInitData } from './telegramAuth';
import { pool } from './db';

export default async function routes(fastify: FastifyInstance) {
  fastify.get('/health', async () => ({ ok: true }));

  fastify.post('/auth', async (request, reply) => {
    const body = request.body as any;
    const initData = body?.initData;
    if (!initData) return reply.code(400).send({ error: 'initData required' });

    const botToken = process.env.TELEGRAM_BOT_TOKEN || '';
    const ok = verifyInitData(initData, botToken);
    if (!ok) return reply.code(401).send({ error: 'invalid initData' });

    const parsed = parseInitData(initData);
    // parsed.user -> may contain JSON with first_name, id etc (initDataUnsafe). For safety use minimal.
    // For anonymity: DO NOT store tg_user_id unless you want to link.
    // Create or find anon profile:
    const anonName = `User${Math.floor(Math.random()*9000)+1000}`;
    const res = await pool.query(
      'INSERT INTO users(tg_user_id, anon_name) VALUES($1,$2) ON CONFLICT (tg_user_id) DO UPDATE SET anon_name=EXCLUDED.anon_name RETURNING id, anon_name',
      [null, anonName]
    );
    const user = res.rows[0];
    // Create a simple session token (in prod use secure JWT / Redis session)
    const token = Math.random().toString(36).slice(2);
    // TODO: save token -> session storage (Redis) mapping to user.id
    return { token, user };
  });

  // endpoint to fetch history
  fastify.get('/rooms/:id/messages', async (request, reply) => {
    const { id } = (request.params as any);
    const res = await pool.query('SELECT m.*, u.anon_name FROM messages m LEFT JOIN users u ON u.id = m.user_id WHERE room_id = $1 ORDER BY created_at DESC LIMIT 200', [id || 1]);
    return res.rows.reverse(); // send oldest first
  });
}

backend/src/server.ts
import Fastify from 'fastify';
import fastifyIO from 'fastify-socket.io';
import routes from './routes';
import { setupSocket } from './socket';
import { initDb } from './db';
import dotenv from 'dotenv';
dotenv.config();

const fastify = Fastify({ logger: true });

await initDb();

await fastify.register(fastifyIO, {
  // options
  cors: {
    origin: true,
    credentials: true
  }
});

fastify.register(routes);

fastify.ready().then(() => {
  setupSocket(fastify);
});

const port = parseInt(process.env.PORT || '3000', 10);
fastify.listen({ port, host: '0.0.0.0' }).then(() => {
  fastify.log.info(`Server listening on ${port}`);
});

backend/sql/init.sql
-- use this to initialize DB if not using initDb()
CREATE TABLE users(
  id SERIAL PRIMARY KEY,
  tg_user_id BIGINT NULL UNIQUE,
  anon_name TEXT,
  avatar_url TEXT,
  created_at TIMESTAMPTZ DEFAULT now()
);

CREATE TABLE rooms(
  id SERIAL PRIMARY KEY,
  name TEXT,
  type TEXT DEFAULT 'group',
  created_at TIMESTAMPTZ DEFAULT now()
);

CREATE TABLE messages(
  id SERIAL PRIMARY KEY,
  room_id INTEGER REFERENCES rooms(id),
  user_id INTEGER REFERENCES users(id),
  content TEXT,
  created_at TIMESTAMPTZ DEFAULT now()
);

frontend/package.json
{
  "name": "frontend",
  "version": "1.0.0",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview --port 8080"
  },
  "dependencies": {
    "socket.io-client": "^4.7.0"
  },
  "devDependencies": {
    "vite": "^5.0.0",
    "react": "^18.2.0",
    "react-dom": "^18.2.0"
  }
}

frontend/vite.config.js
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

export default defineConfig({
  plugins: [react()],
  server: {
    port: 5173,
    host: true
  }
});

frontend/src/telegram.js
// minimal wrapper for Telegram WebApp
export function getInitData() {
  // Telegram WebApp provides window.Telegram.WebApp.initData (string)
  if (window.Telegram && window.Telegram.WebApp) {
    return window.Telegram.WebApp.initData || null;
  }
  // else fallback to URL param (for local dev)
  const params = new URLSearchParams(window.location.search);
  return params.get('initData') || null;
}

frontend/src/main.jsx
import React from 'react'
import { createRoot } from 'react-dom/client'
import App from './App'
import './style.css'

createRoot(document.getElementById('root')).render(<App />)

frontend/src/App.jsx
import React, { useEffect, useState } from 'react';
import Chat from './Chat';
import { getInitData } from './telegram';

const SERVER = import.meta.env.VITE_SERVER_URL || 'http://localhost:3000';

export default function App(){
  const [token, setToken] = useState(null);
  const [user, setUser] = useState(null);

  useEffect(() => {
    async function auth() {
      const initData = getInitData();
      const res = await fetch(`${SERVER}/auth`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ initData })
      });
      if (res.ok) {
        const data = await res.json();
        setToken(data.token);
        setUser(data.user);
      } else {
        console.error('auth failed', await res.text());
      }
    }
    auth();
  }, []);

  if (!token) return <div>Авторизация...</div>;
  return <Chat server={SERVER} token={token} user={user} />
}

frontend/src/Chat.jsx
import React, { useEffect, useState } from 'react';
import { io } from 'socket.io-client';

export default function Chat({ server, token, user }) {
  const [socket, setSocket] = useState(null);
  const [messages, setMessages] = useState([]);
  const [text, setText] = useState('');

  useEffect(() => {
    const s = io(server, { auth: { token } });
    s.on('connect', () => {
      console.log('connected', s.id);
      s.emit('auth', { token });
    });
    s.on('message', (msg) => {
      setMessages(prev => [...prev, msg]);
    });
    setSocket(s);
    return () => s.disconnect();
  }, [server, token]);

  const send = () => {
    if (!text.trim()) return;
    socket.emit('message', { roomId: 1, userId: user?.id || null, content: text });
    setText('');
  };

  return (
    <div style={{padding:20}}>
      <h3>Анонимный чат (MVP)</h3>
      <div style={{border:'1px solid #ddd', height:400, overflow:'auto', padding:10}}>
        {messages.map((m,i)=> <div key={i}><b>{m.userId || 'anon'}:</b> {m.content}</div>)}
      </div>
      <div style={{marginTop:10}}>
        <input value={text} onChange={e=>setText(e.target.value)} style={{width:'80%'}} />
        <button onClick={send}>Отправить</button>
      </div>
    </div>
  );
}